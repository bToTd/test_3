{"version":3,"sources":["BehaviorTree.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"../../../../../../../assets/Scripts/src/behavior/core","sourcesContent":["import { createUUID } from '../b3.functions';\nimport { COMPOSITE, DECORATOR } from '../constants';\nimport * as Decorators from '../decorators';\nimport * as Composites from '../composites';\nimport * as Actions from '../actions';\nimport * as Conditions from '../conditions';\nimport Tick from './Tick';\nimport { BaseNodeData } from '../interf';\n\n/**\n * The BehaviorTree class, as the name implies, represents the Behavior Tree\n * structure.\n *\n * There are two ways to construct a Behavior Tree: by manually setting the\n * root node, or by loading it from a data structure (which can be loaded\n * from a JSON). Both methods are shown in the examples below and better\n * explained in the user guide.\n *\n * The tick method must be called periodically, in order to send the tick\n * signal to all nodes in the tree, starting from the root. The method\n * `BehaviorTree.tick` receives a target object and a blackboard as\n * parameters. The target object can be anything: a game agent, a system, a\n * DOM object, etc. This target is not used by any piece of Behavior3JS,\n * i.e., the target object will only be used by custom nodes.\n *\n * The blackboard is obligatory and must be an instance of `Blackboard`. This\n * requirement is necessary due to the fact that neither `BehaviorTree` or\n * any node will store the execution variables in its own object (e.g., the\n * BT does not store the target, information about opened nodes or number of\n * times the tree was called). But because of this, you only need a single\n * tree instance to control multiple (maybe hundreds) objects.\n *\n * Manual construction of a Behavior Tree\n * --------------------------------------\n *\n *     var tree = new b3.BehaviorTree();\n *\n *     tree.root = new b3.Sequence({children:[\n *       new b3.Priority({children:[\n *         new MyCustomNode(),\n *         new MyCustomNode()\n *       ]}),\n *       ...\n *     ]});\n *\n *\n * Loading a Behavior Tree from data structure\n * -------------------------------------------\n *\n *     var tree = new b3.BehaviorTree();\n *\n *     tree.load({\n *       'title'       : 'Behavior Tree title'\n *       'description' : 'My description'\n *       'root'        : 'node-id-1'\n *       'nodes'       : {\n *         'node-id-1' : {\n *           'name'        : 'Priority', // this is the node type\n *           'title'       : 'Root Node',\n *           'description' : 'Description',\n *           'children'    : ['node-id-2', 'node-id-3'],\n *         },\n *         ...\n *       }\n *     })\n *\n *\n * @module b3\n * @class BehaviorTree\n **/\n\ninterface behaviorTreeData {\n  title?:string,\n  id?:string,\n  description: string,\n  properties: any,\n  root: any,\n  debug: any,\n  nodes: any,\n  custom_nodes: any\n}\n\nexport default class BehaviorTree {\n  id: string;\n  title: string;\n  description: string;\n  properties: {};\n  root: any;\n  debug: any;\n\n  /**\n   * Initialization method.\n   * @method initialize\n   * @constructor\n   **/\n  constructor() {\n    /**\n     * The tree id, must be unique. By default, created with `createUUID`.\n     * @property {String} id\n     * @readOnly\n     **/\n    this.id = createUUID();\n\n    /**\n     * The tree title.\n     * @property {String} title\n     * @readonly\n     **/\n    this.title = 'The behavior tree';\n\n    /**\n     * Description of the tree.\n     * @property {String} description\n     * @readonly\n     **/\n    this.description = 'Default description';\n\n    /**\n     * A dictionary with (key-value) properties. Useful to define custom\n     * variables in the visual editor.\n     *\n     * @property {Object} properties\n     * @readonly\n     **/\n    this.properties = {};\n\n    /**\n     * The reference to the root node. Must be an instance of `BaseNode`.\n     * @property {BaseNode} root\n     **/\n    this.root = null;\n\n    /**\n     * The reference to the debug instance.\n     * @property {Object} debug\n     **/\n    this.debug = null;\n  }\n\n  /**\n   * This method loads a Behavior Tree from a data structure, populating this\n   * object with the provided data. Notice that, the data structure must\n   * follow the format specified by Behavior3JS. Consult the guide to know\n   * more about this format.\n   *\n   * You probably want to use custom nodes in your BTs, thus, you need to\n   * provide the `names` object, in which this method can find the nodes by\n   * `names[NODE_NAME]`. This variable can be a namespace or a dictionary,\n   * as long as this method can find the node by its name, for example:\n   *\n   *     //json\n   *     ...\n   *     'node1': {\n   *       'name': MyCustomNode,\n   *       'title': ...\n   *     }\n   *     ...\n   *\n   *     //code\n   *     var bt = new b3.BehaviorTree();\n   *     bt.load(data, {'MyCustomNode':MyCustomNode})\n   *\n   *\n   * @method load\n   * @param {Object} data The data structure representing a Behavior Tree.\n   * @param {Object} [names] A namespace or dict containing custom nodes.\n   **/\n  load(data, names) {\n    names = names || {};\n\n    this.title = data.title || this.title;\n    this.description = data.description || this.description;\n    this.properties = data.properties || this.properties;\n\n    var nodes = {};\n    var id, spec, node;\n    // Create the node list (without connection between them)\n    for (id in data.nodes) {\n      spec = data.nodes[id];\n      var Cls;\n\n      if (spec.name in names) {\n        // Look for the name in custom nodes\n        Cls = names[spec.name];\n      } else if (spec.name in Decorators) {\n        // Look for the name in default nodes\n        Cls = Decorators[spec.name];\n      } else if (spec.name in Composites) {\n        Cls = Composites[spec.name];\n      } else if (spec.name in Actions) {\n        Cls = Actions[spec.name];\n      } else if (spec.name in Conditions) {\n        Cls = Conditions[spec.name];\n      } else {\n        // Invalid node name\n        throw new EvalError('BehaviorTree.load: Invalid node name + \"' +\n          spec.name + '\".');\n      }\n\n      node = new Cls(spec.properties);\n      node.id = spec.id || node.id;\n      node.title = spec.title || node.title;\n      node.description = spec.description || node.description;\n      node.properties = spec.properties || node.properties;\n\n      nodes[id] = node;\n    }\n\n    // Connect the nodes\n    for (id in data.nodes) {\n      spec = data.nodes[id];\n      node = nodes[id];\n\n      if (node.category === COMPOSITE && spec.children) {\n        for (var i = 0; i < spec.children.length; i++) {\n          var cid = spec.children[i];\n          node.children.push(nodes[cid]);\n        }\n      } else if (node.category === DECORATOR && spec.child) {\n        node.child = nodes[spec.child];\n      }\n    }\n\n    this.root = nodes[data.root];\n  }\n\n  /**\n   * This method dump the current BT into a data structure.\n   *\n   * Note: This method does not record the current node parameters. Thus,\n   * it may not be compatible with load for now.\n   *\n   * @method dump\n   * @return {Object} A data object representing this tree.\n   **/\n  dump() {\n    var data:behaviorTreeData;\n    var customNames = [];\n\n    data.title = this.title;\n    data.description = this.description;\n    data.root = (this.root) ? this.root.id : null;\n    data.properties = this.properties;\n    data.nodes = {};\n    data.custom_nodes = [];\n\n    if (!this.root) return data;\n\n    var stack = [this.root];\n    while (stack.length > 0) {\n      var node = stack.pop();\n\n      var spec:BaseNodeData;\n      spec.id = node.id;\n      spec.name = node.name;\n      spec.title = node.title;\n      spec.description = node.description;\n      spec.properties = node.properties;\n      spec.parameters = node.parameters;\n\n      // verify custom node\n      var proto = (node.constructor && node.constructor.prototype);\n      var nodeName = (proto && proto.name) || node.name;\n      if (!Decorators[nodeName] && !Composites[nodeName] && !Actions[nodeName] && customNames.indexOf(nodeName) < 0) {\n        var subdata:BaseNodeData;\n        subdata.name = nodeName;\n        subdata.title = (proto && proto.title) || node.title;\n        subdata.category = node.category;\n\n        customNames.push(nodeName);\n        data.custom_nodes.push(subdata);\n      }\n\n      // store children/child\n      if (node.category === COMPOSITE && node.children) {\n        var children = [];\n        for (var i = node.children.length - 1; i >= 0; i--) {\n          children.push(node.children[i].id);\n          stack.push(node.children[i]);\n        }\n        spec.children = children;\n      } else if (node.category === DECORATOR && node.child) {\n        stack.push(node.child);\n        spec.child = node.child.id;\n      }\n\n      data.nodes[node.id] = spec;\n    }\n\n    return data;\n  }\n\n  /**\n   * Propagates the tick signal through the tree, starting from the root.\n   *\n   * This method receives a target object of any type (Object, Array,\n   * DOMElement, whatever) and a `Blackboard` instance. The target object has\n   * no use at all for all Behavior3JS components, but surely is important\n   * for custom nodes. The blackboard instance is used by the tree and nodes\n   * to store execution variables (e.g., last node running) and is obligatory\n   * to be a `Blackboard` instance (or an object with the same interface).\n   *\n   * Internally, this method creates a Tick object, which will store the\n   * target and the blackboard objects.\n   *\n   * Note: BehaviorTree stores a list of open nodes from last tick, if these\n   * nodes weren't called after the current tick, this method will close them\n   * automatically.\n   *\n   * @method tick\n   * @param {Object} target A target object.\n   * @param {Blackboard} blackboard An instance of blackboard object.\n   * @return {Constant} The tick signal state.\n   **/\n  tick(target, blackboard) {\n    if (!blackboard) {\n      throw 'The blackboard parameter is obligatory and must be an ' +\n      'instance of b3.Blackboard';\n    }\n\n    /* CREATE A TICK OBJECT */\n    var tick = new Tick();\n    tick.debug = this.debug;\n    tick.target = target;\n    tick.blackboard = blackboard;\n    tick.tree = this;\n\n    /* TICK NODE */\n    var state = this.root._execute(tick);\n\n    /* CLOSE NODES FROM LAST TICK, IF NEEDED */\n    var lastOpenNodes = blackboard.get('openNodes', this.id);\n    var currOpenNodes = tick._openNodes.slice(0);\n\n    // does not close if it is still open in this tick\n    var start = 0;\n    var i;\n    for (i = 0; i < Math.min(lastOpenNodes.length, currOpenNodes.length); i++) {\n      start = i + 1;\n      if (lastOpenNodes[i] !== currOpenNodes[i]) {\n        break;\n      }\n    }\n\n    // close the nodes\n    for (i = lastOpenNodes.length - 1; i >= start; i--) {\n      lastOpenNodes[i]._close(tick);\n    }\n\n    /* POPULATE BLACKBOARD */\n    blackboard.set('openNodes', currOpenNodes, this.id);\n    blackboard.set('nodeCount', tick._nodeCount, this.id);\n\n    return state;\n  }\n};\n"]}